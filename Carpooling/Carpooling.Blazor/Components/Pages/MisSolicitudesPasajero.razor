@page "/solicitudes"
@rendermode InteractiveServer

@using DTOs
@using API.Clients
@using Domain.Model
@using API.Auth.Blazor
@inject ServicioSesionUsuario SesionUsuario
@inject NavigationManager Navigation
@inject IJSRuntime JSRuntime

<PageTitle>Mis Solicitudes</PageTitle>

<h3>Mis Solicitudes de Viajes</h3>

@* Mensaje de error general *@
@if (!string.IsNullOrEmpty(errorMensaje))
{
    <div class="alert alert-danger" role="alert">
        @errorMensaje
    </div>
}

@if (puedeAcceder) // Si el usuario tiene permisos
{
    @if (solicitudes == null) // Si aún está cargando
    {
        <p><em>Cargando solicitudes...</em></p>
    }
    else if (solicitudes.Count == 0) // Si no tiene viajes
    {
        <p>No tienes solicitudes.</p>
        //
    }
    else // Si hay viajes, muestra la tabla
    {
        <table class="table table-striped">
            <thead>
                <tr>
                    <th>Estado</th>
                    <th>Solicitada</th>
                    <th>Origen</th>
                    <th>Destino</th>
                    <th>Estado Viaje</th>
                    <th>Conductor</th>
                    <th>Fecha de Viaje</th>
                    <th>Patente Vehiculo</th>
                    <th>Acciones</th>
                </tr>
            </thead>
            <tbody>
                @foreach (var sol in solicitudes) // Itera sobre la lista de viajes
                {
                    {viaje = viajes.Where(v => v.IdViaje == sol.IdViaje).First();}
                    <tr>
                        <td>@sol.Estado</td>
                        <td>@sol.SolicitudFecha.ToString("dd/MM/yyyy HH:mm")</td>
                        <td>@viaje.NombreOrigen</td> @* Muestra el nombre del origen si está disponible *@
                        <td>@viaje.NombreDestino</td> @* Muestra el nombre del destino si está disponible *@
                        <td>@viaje.Estado</td>
                        <td>@sol.NombreConductor @sol.ApellidoConductor</td>
                        <td>@viaje.FechaHora.ToString("dd/MM/yyyy HH:mm")</td>
                        <td>@viaje.Patente</td>
                        <td>
                            @* --- Lógica Condicional para Botones --- *@
                            @if (sol.Estado == EstadoSolicitud.Pendiente)
                            {
                                <button class="btn btn-danger btn-sm me-1" @onclick="() => CancelarSolicitud(sol.IdSolicitud)" disabled="@procesandoAccion">Cancelar Solicitud</button>
                            }
                            else if (sol.Estado == EstadoSolicitud.Aprobada && viaje.Estado == EstadoViaje.Realizado)
                            {
                                <button class="btn btn-success btn-sm me-1" @onclick="() => IrCalificarConductor(sol.IdViaje)" disabled="@procesandoAccion">Calificar Conductor</button>
                            }
                            @* --- Fin Lógica Condicional --- *@
                        </td>
                    </tr>
                }
            </tbody>
        </table>
    }
}
else // Si el usuario no tiene permisos
{
    <p><em>Verificando permisos...</em></p>
    @if (!puedeAcceder && SesionUsuario.EstaLogueado)
    {
        <div class="alert alert-warning mt-3">No tienes permiso para acceder a esta sección.</div>
        //
    }
}

@code {
    private List<SolicitudViajeDTO>? solicitudes;
    private List<ViajeDTO> viajes;
    private ViajeDTO viaje;
    private bool puedeAcceder = false; // Flag para controlar acceso
    private bool procesandoAccion = false; // Flag para deshabilitar botones durante llamadas API
    private string? errorMensaje; // Para mostrar errores generales

    string? token; 

    // Método que se ejecuta al inicializar el componente
    protected override async Task OnInitializedAsync()
    {

        if (SesionUsuario.EstaLogueado &&
            (SesionUsuario.UsuarioActual?.TipoUsuario == Domain.Model.TipoUsuario.PasajeroConductor ||
             SesionUsuario.UsuarioActual?.TipoUsuario == Domain.Model.TipoUsuario.Pasajero)) //
        {
            puedeAcceder = true; // Permite acceso
            await CargarSolicitudes(); // Carga la lista de viajes
            await CargarViajes();
        }
        else if (SesionUsuario.EstaLogueado)
        {
            // Logueado pero no tiene el rol correcto
            puedeAcceder = false;
        }
        else
        {
            // No está logueado
            Navigation.NavigateTo("/login"); // Redirige a login
        }
    }

    private async Task CargarSolicitudes()
    {
        var isAuthenticated = await SesionUsuario.IsAuthenticatedAsync();
        if (isAuthenticated)
        {
            await SesionUsuario.CheckTokenExpirationAsync();
            token = await SesionUsuario.GetTokenAsync();
            var res = await SolicitudViajeApiClient.GetSolicitudesPorPasajeroAsync(SesionUsuario.UsuarioActual.IdUsuario, token);
            solicitudes = res.ToList();
        }
        else { Navigation.NavigateTo("/login"); }
    }
    // Método asíncrono para cargar los viajes desde la API
    private async Task CargarViajes()
    {

        if (!puedeAcceder || token == null) return; // Si no tiene acceso o token, no hace nada

        try
        {
            await SesionUsuario.CheckTokenExpirationAsync(); 
            token = await SesionUsuario.GetTokenAsync(); 
            if (token == null)
            {
                throw new InvalidOperationException("La sesión ha expirado. Por favor, inicie sesión de nuevo.");
            }


            viajes = new List<ViajeDTO>();
            foreach(var sol in solicitudes)
            {
                ViajeDTO v = await ViajeApiClient.GetAsync(sol.IdViaje.ToString());
                viajes.Add(v);
            }

        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error al cargar viajes: {ex.Message}");
            errorMensaje = $"No se pudieron cargar los viajes: {ex.Message}"; // Guarda el mensaje de error
            viajes = new List<ViajeDTO>(); // Asigna lista vacía en caso de error
        }
        InvokeAsync(StateHasChanged); // Notifica a Blazor para que actualice la interfaz gráfica
    }

    // Método asíncrono para cancelar un viaje
    private async Task CancelarSolicitud(int idSoli)
    {

        if (procesandoAccion) return; // Evita ejecuciones múltiples si ya se está procesando
        procesandoAccion = true; // Marca que una acción está en curso
        errorMensaje = null; // Limpia errores
        await Task.Delay(1); // Pequeño delay para que la UI muestre el botón deshabilitado

        try
        {
            await SesionUsuario.CheckTokenExpirationAsync(); // Revisa token
            token = await SesionUsuario.GetTokenAsync(); // Obtiene token
            if (token == null) throw new InvalidOperationException("Sesión expirada.");

            // Muestra un diálogo de confirmación usando JavaScript
            bool confirmado = await JSRuntime.InvokeAsync<bool>("confirm", "¿Está seguro de que desea cancelar este viaje?");
            if (!confirmado) return; // Si el usuario cancela, no hace nada

            // Llama a la API para cancelar (eliminar lógicamente)
            await SolicitudViajeApiClient.CancelarSolicitudPasajeroAsync(idSoli, token); //
            await CargarViajes(); // Vuelve a cargar la lista para reflejar el cambio de estado
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error al cancelar la solicitud {idSoli}: {ex.Message}");
            errorMensaje = $"Error al cancelar viaje: {ex.Message}"; // Guarda el error
        }
        finally
        {
            procesandoAccion = false; // Marca que la acción terminó
            await CargarSolicitudes();
            await InvokeAsync(StateHasChanged); // Actualiza la UI
        }
    }



    // Método para navegar a la página de calificación (a implementar)
    private void IrCalificarConductor(int idViaje)
    {
        // Navega a una URL específica para calificar, pasando el ID del viaje
        Navigation.NavigateTo($"/calificar-conductor/{idViaje}");
        
        //InvokeAsync(StateHasChanged);
    }
}